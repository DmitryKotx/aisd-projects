# AISD_projects

Это задачи, которые я выполнял в рамках курса "Алгоритмы и стурктуры данных".

Условия задач:
1. Описание интерфейса класса. Должна быть предусмотрена генерация кода. Т.е.
   необходимо в виде объектов (метод, параметр и т.п.) описать интерфейс и созданный
   объект интерфейса должен уметь возвращать свое описание в виде кода на Java.
   Предполагает наличие классов для описания параметра и метода.
2. Написать рекурсивную реализацию переворачивания (1-ый элемент становится
   последним, 2-ой – предпоследним и т.д.) односвязного списка. Новых объектов ListNode/ListItem – не создавать.
3. Очереди.Смоделировать следующую игру. Берется колода карт, перемешивается. Верхняя карта
   кладется на стол. Далее берется следующая карта, если она той же масти или
   достоинства, то кладется на карту на столе, в противном случае перекладывается вниз
   стопки карт. Действия продолжаются, пока в стопке карт остаются карты, которые
   можно положить на самую верхнюю карту на столе по описанным правилам.
   Необходимо найти, а) сколько будет сделано ходов, б) какие карты и в каком порядке
   окажутся на столе, в) какие карты и в каком порядке останутся в стопке карт.
   «Рисовать» анимацию не требуется, только в каком-либо виде показать, какие карты и в
   каком порядке были вначале, а также результат «игры» (пункты а, б, в).
4. Написать программу, которая иллюстрирует работу сортировки пузырьком (Bubble
   sort) на примере массива целых чисел. Для описания текущего состояния сортировки
   должен быть описан класс SortState, в котором будут храниться:
   – массив (текущее состояние на данном шаге, естественно, надо делать копию
   массива, т.к. исходный массив будет меняться в процессе сортировки);
   – переменная цикла i;
   – переменная вложенного цикла j;
   – возможно еще какие-то данные, необходимые для визуализации.
   В модифицированной процедуре сортировки помимо соответствующих действий на
   каждом шаге необходимо создать экземпляр класса SortState, соответствующий
   текущему шагу сортировки, и добавлять этот экземпляр в список состояний, который
   будет возвращаться, т.е. сортировка будет иметь следующую сигнатуру:
   List<SortState> sort(int[] arr)
   Далее необходимо реализовать наглядное отображение на форме состояния SortState
   (возможно с использованием JTable или нарисовать). К таймеру следует привязать
   обработчик событий, который будет обновлять форму (перерисовывать очередное
   состояние в процессе сортировки).
   Таким образом, непосредственно сортировка выполняется сразу же, а отображение на
   форме произошедших событий осуществляется позже с задержками, чтобы пользователь
   мог оценить, что происходит.
   Предусмотреть режим, когда таймер отключается и очередное состояние отображается
   по нажатию кнопки (причем, чтобы можно было «проигрывать» события как вперед, так
   и назад).
5. В заданном двоичном дереве найти поддерево двоичного поиска с
   максимальным количеством элементов.
6. Есть файл с информацией об оценках студентов по предметам. Формат файла – CSV
   (предмет, ФИО, оценка). Оценка – число или зачет/незачет (т.е. строка). Записи в файле
   расположены в произвольном порядке. Обеспечить поиск информации обо всех оценках
   указанного студента. Использовать структуру данных Map<String, Map<String, String>>
   (Map<ФИО, Map<Предмет, Оценка>>). Реализовать в виде оконного приложения, где
   можно выбрать ФИО, а в таблице ниже отобразиться список оценок студента. (Задача
   повышенной сложности из-за того, что надо много всего сделать в плане реализации
   интерфейса, сами алгоритмы – тривиальны).
7. N колец сцеплены между собой (задана матрица A(n*n), A(i,j)=1 в случае, если кольца
   i и j сцеплены друг с другом и A(i,j)=0 иначе). Удалить минимальное количество
   колец так, чтобы получилась цепочка..
8. Неориентированный граф называется полным двудольным, если его можно раскрасить в
   два цвета так, что концы любого ребра будут разного цвета и каждая вершина одного
   цвета будет соединена со всеми вершинами другого цвета. Составить алгоритм проверки,
   является ли заданный граф полным двудольным
